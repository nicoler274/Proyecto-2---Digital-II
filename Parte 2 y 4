//******************************************/
// Universidad del Valle de Guatemala
// BE3029 - Electronica Digital 2
// Maryela Morales y Nicole rodriguez
// 03/11/2025
// Proyecto de laboratorio
// MCU: ESP32 dev kit 1.0
//******************************************/

//******************************************/
// Librerias
//******************************************/
// Se añaden librerías para el correcto funcionamiento del sistema
#include <Arduino.h>
#include <LiquidCrystal.h>
#include <ESP32SPISlave.h>
#include <Wire.h>

//******************************************/
// Definiciones
//******************************************/
// Defincion de LEDs
#define ledR 15
#define ledG 2
#define ledA 4

// Defincion de potenciometro
#define pot1 33

// Defincion de pines de pantalla LCD
#define rs 34
#define en 32
#define d4 25
#define d5 26
#define d6 27
#define d7 14

// Definicion de pines para SPI
#define SPI_SCK 5
#define SPI_MISO 18
#define SPI_MOSI 19
#define SPI_SS 21

// Definicion I2C
#define I2C_DEV_ADDR 0x55

// Canales PWM
#define pwmChannel1 0
#define pwmChannel2 1
#define pwmChannel3 2
// Frecuencia para leds
#define freqPWM 5000
// Resolucion de pwm 
#define resPWM 8

//******************************************/
// Variables globales
//******************************************/
// Contadores
uint8_t contador = 0;

String serialCommand = "";
bool newCommand = false;
bool modoComando = false;
bool modoSPI = false;

// Variables para cambio de leds
int valorRojo = 0;
int valorVerde = 0;
int valorAmarillo = 0;

// Instanciar objeto LCD
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

// Variables para SPI
// Configurar ESP como esclavo
ESP32SPISlave slave;
static constexpr u_int32_t BUFFER_SIZE{32};
uint8_t spi_slave_tx_buf[BUFFER_SIZE];
uint8_t spi_slave_rx_buf[BUFFER_SIZE];
//comando para el SPI
int spiLed = 0;
int spiTiempo = 0;
bool spiCmd = false;

// Para ultimo led
String ultimoLED = "N"; //Donde N = ninguno

// Variables para I2C
uint8_t I2Cbuffer[4];
bool I2CCmd = false;
int i2cLed = 0;
int i2cTiempo = 0;

//******************************************/
// Prototipos de funciones
//******************************************/
void initPWM();
void initSPI();
void ejecutarComandoLed(int led, int tiempo);
//void procesarComandoSerial();
void procesarComandoSPI();
void actualizarLCD(float voltaje, int valorBits, String ultimoLED);
void onReceive (int numBytes);
void onRequest ();

//******************************************/
// Otras funciones
//******************************************/
void initPWM(){
  ledcSetup(pwmChannel1, freqPWM, resPWM);
  ledcAttachPin(ledR, pwmChannel1);
  ledcWrite(pwmChannel1, 0);

  ledcSetup(pwmChannel2, freqPWM, resPWM);
  ledcAttachPin(ledG, pwmChannel2);
  ledcWrite(pwmChannel2, 0);

  ledcSetup(pwmChannel3, freqPWM, resPWM);
  ledcAttachPin(ledA, pwmChannel3);
  ledcWrite(pwmChannel3, 0);
}
void initSPI(){
  // Configurar pines SPI
  pinMode(SPI_SS, INPUT_PULLUP);
  
  // Configurar slave SPI
  slave.setDataMode(SPI_MODE0);
  slave.setQueueSize(1);
  slave.begin(VSPI, SPI_SCK, SPI_MISO, SPI_MOSI, SPI_SS);
}

void ejecutarComandoLed(int led, int tiempo)
{
  // Apagado de leds
  ledcWrite(pwmChannel1, 0);
  ledcWrite(pwmChannel2, 0);
  ledcWrite(pwmChannel3, 0);

  // Actualizacion de último LED
  switch (led){
  case 1:
    ultimoLED = "R";
    break;
  case 2:
    ultimoLED = "G";
    break;
  case 3:
    ultimoLED = "A";
    break;
  }

  // Switch case para encender el led especifico
  switch (led)
  {
  case 1:
    ledcWrite(pwmChannel1, 255);
    Serial.println("Led Rojo encendido");
    break;
  case 2:
    ledcWrite(pwmChannel2, 255);
    Serial.println("Led Verde encendido");
    break;
  case 3:
    ledcWrite(pwmChannel3, 255);
    Serial.println("Led Amarillo encendido");
    break;
  default:
    return;
  }
  // Esperar el tiempo especificado
  Serial.print("Tiempo: ");
  Serial.println(tiempo);
  delay(tiempo);

  // Apagar el LED después del tiempo
  switch (led)
  {
  case 1:
    ledcWrite(pwmChannel1, 0);
    break;
  case 2:
    ledcWrite(pwmChannel2, 0);
    break;
  case 3:
    ledcWrite(pwmChannel3, 0);
    break;
  }
  // Banderas para iniciar de nuevo y recibir comando
  modoComando = false;
  modoSPI = false;
  spiCmd = false;
  I2CCmd = false;
}

void procesarComandoSPI(){
  Serial.println("Procesando comando SPI");
    Serial.print("LED: ");
    Serial.print(spiLed);
    Serial.print(", Tiempo: ");
    Serial.println(spiTiempo);
    
    modoSPI = true;
    ejecutarComandoLed(spiLed, spiTiempo);
    spiCmd = false;
}

void procesarComandoI2C()
{
  if (I2CCmd) {
    Serial.println("Procesando comando I2C");
    Serial.print("LED: ");
    Serial.print(i2cLed);
    Serial.print(", Tiempo: ");
    Serial.println(i2cTiempo);
    
    modoComando = true;
    ejecutarComandoLed(i2cLed, i2cTiempo);
    I2CCmd = false;
  }
}

void actualizarLCD(float voltaje, int valorBits, String ultimoLED){
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("V:");
  lcd.print(voltaje, 2);
  lcd.print("B:");
  lcd.print(valorBits);

  lcd.setCursor(0, 1);
  lcd.print("Led:");
  lcd.print(ultimoLED);
}

// Funcion I2C
void onReceive(int numBytes) {
  int i = 0;
  while (Wire.available() && i < 4) {
    I2Cbuffer[i] = Wire.read();
    i++;
  }
  
  if (i >= 2) {
    i2cLed = I2Cbuffer[0];
    i2cTiempo = (I2Cbuffer[1] << 8) | I2Cbuffer[2]; // Combinar 2 bytes para tiempo
    I2CCmd = true;
  }
}

void onRequest() {
  // Enviar estado actual (último LED)
  if (ultimoLED == "R") {
    Wire.write(1);
  } else if (ultimoLED == "G") {
    Wire.write(2);
  } else if (ultimoLED == "A") {
    Wire.write(3);
  } else {
    Wire.write(0); // Ningún LED
  }
}

//******************************************/
// Configuracion
//******************************************/
void setup()
{
  Serial.begin(115200);
  initPWM();
  initSPI();

  // Para lectura de potenciometro
  analogReadResolution(12);
  analogSetAttenuation(ADC_11db);

  // Inicializacion de pantalla
  lcd.begin(16, 2);
  lcd.clear();

  // Configuracion de entradas y salidas en ESP
  pinMode(pot1, INPUT);
  pinMode(ledR, OUTPUT);
  pinMode(ledG, OUTPUT);
  pinMode(ledA, OUTPUT);

  // Configuracion para Slave
  // On receive realiza la tarea
  Wire.onReceive(onReceive);
  // On Request da info a Nucleo
  Wire.onRequest(onRequest);
  // Wire.print() --> funcion que envia el valor a nucleo (master)
  Wire.begin((uint8_t)I2C_DEV_ADDR);
  Serial.println("I2C listo");

  // VSPI = CS:5, CLK: 18, MOSI: 23, MISO: 19
  // Clear buffers del spi
  memset(spi_slave_tx_buf, 0, BUFFER_SIZE);
  memset(spi_slave_rx_buf, 0, BUFFER_SIZE);
}

//******************************************/
// Loop Principal
//******************************************/
void loop()
{
  //procesarComandoSerial();
  procesarComandoSPI();
  procesarComandoI2C();
  
  // Procesar SPI
  if (slave.available()) {
    slave.wait(spi_slave_rx_buf, spi_slave_tx_buf, BUFFER_SIZE);
    
    // Procesar datos recibidos por SPI
    // Formato esperado: [LED, Tiempo]
    if (spi_slave_rx_buf[0] >= 1 && spi_slave_rx_buf[0] <= 3) {
      spiLed = spi_slave_rx_buf[0];
      spiTiempo = (spi_slave_rx_buf[1] << 8) | spi_slave_rx_buf[2];
      
      if (spiTiempo > 0) {
        spiCmd = true;
        Serial.println("Comando SPI recibido");
      }
    }
    // Limpiar buffer (CREO)
    memset(spi_slave_rx_buf, 0, BUFFER_SIZE);
    slave.pop();
  }

  // Espera de un comando para iniciar
  if (newCommand){
    String comando = serialCommand;
    serialCommand = "";
    newCommand = false;

    // Esperar comando (formato: "LED,tiempo")
    int led, tiempo;
    if (sscanf(comando.c_str(), "%d,%d", &led, &tiempo) == 2)
    {
      if (tiempo > 0 && led >= 1 && led <= 3){
        modoComando = true;
        Serial.println("\n se activa modo comando");
        ejecutarComandoLed(led, tiempo);
      }
      else{
        Serial.println("error: Tiempo debe ser > 0 y Led entre 1-3");
      }
    }
    else{
      Serial.println("error: Formato inválido. Use: Led ,Tiempo");
    }
  }

  if (!modoComando && !modoSPI && !spiCmd && !I2CCmd){
    int pot = analogRead(pot1);

    // Calculo de valores en voltaje y bits
    float voltaje = (pot * 3.3) / 4095.0;
    int valorBits = pot;

    // Mapeo de valores para los leds
    valorRojo = map(pot, 0, 4095, 0, 255);
    valorVerde = map(pot, 0, 4095, 0, 255);
    valorAmarillo = map(pot, 0, 4095, 0, 255);
    
    static unsigned long lastLCDUpdate =0;
    if (millis() - lastLCDUpdate >= 300){
      actualizarLCD(voltaje, valorBits, ultimoLED);
      lastLCDUpdate = millis();

      // Debug en monitor serial y ver que todo esta bien
      Serial.print("Pot: ");
      Serial.print(voltaje, 2);
      Serial.print("V, Bits: ");
      Serial.print(valorBits);
      Serial.print(", Ultimo Led Cmd: ");
      Serial.println(ultimoLED);
    }
  }
}
