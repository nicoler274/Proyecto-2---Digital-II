//******************************************/
// Universidad del Valle de Guatemala
// BE3029 - Electronica Digital 2
// Maryela Morales y Nicole rodriguez
// 03/11/2025
// Proyecto de laboratorio
// MCU: ESP32 dev kit 1.0
//******************************************/

//******************************************/
// Librerias
//******************************************/
// Se añaden librerías para el correcto funcionamiento del sistema
#include <Arduino.h>
#include <LiquidCrystal.h>
#include <ESP32SPISlave.h>
#include <Wire.h>

//******************************************/
// Definiciones
//******************************************/
// Defincion de LEDs
#define ledR 15
#define ledG 2
#define ledA 4

// Defincion de potenciometro
#define pot1 33

// Defincion de pines de pantalla LCD
#define rs 34
#define en 32
#define d4 25
#define d5 26
#define d6 27
#define d7 14

// Definicion de pines para SPI
#define SPI_SCK 5
#define SPI_MISO 18
#define SPI_MOSI 19
#define SPI_SS 21

// Definicion I2C
#define I2C_DEV_ADDR 0x55

// Canales PWM
#define pwmChannel1 0
#define pwmChannel2 1
#define pwmChannel3 2
// Paso #3 escoger la frecuencia
#define freqPWM 5000
// Paso #4 escoger resolucion de pwm
#define resPWM 8

//******************************************/
// Variables globales
//******************************************/
// Contadores
uint8_t contador = 0;

String serialCommand = "";
bool newCommand = false;
bool modoComando = false;
bool modoSPI = false;

// Variables para cambio de leds
int valorRojo = 0;
int valorVerde = 0;
int valorAmarillo = 0;

// Instanciar objeto LCD
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

// Variables para SPI
volatile byte spiData[4];
volatile byte spiIndex = 0;
volatile bool spiCommandReady = false;
volatile bool spiActive = false;

// Configurar ESP como esclavo
ESP32SPISlave slave;
static constexpr u_int32_t BUFFER_SIZE{32};
uint8_t spi_slave_tx_buf[BUFFER_SIZE];
uint8_t spi_slave_rx_buf[BUFFER_SIZE];
//comando para el SPI
char cmd;

// Para ultimo led
String ultimoLED = "N";

// Variables para I2C
uint8_t I2CData[3];
bool i2cCommandReady = false;

//******************************************/
// Prototipos de funciones
//******************************************/
void initPWM();
void initSPI();
void ejecutarComandoLed(int led, int tiempo);
void procesarComandoSerial();
void procesarComandoSPI();
void actualizarLCD(float voltaje, int valorBits, String ultimoLED);

//******************************************/
// Otras funciones
//******************************************/
void initPWM()
{
  ledcSetup(pwmChannel1, freqPWM, resPWM);
  ledcAttachPin(ledR, pwmChannel1);
  ledcWrite(pwmChannel1, 0);

  ledcSetup(pwmChannel2, freqPWM, resPWM);
  ledcAttachPin(ledG, pwmChannel2);
  ledcWrite(pwmChannel2, 0);

  ledcSetup(pwmChannel3, freqPWM, resPWM);
  ledcAttachPin(ledA, pwmChannel3);
  ledcWrite(pwmChannel3, 0);
}

void ejecutarComandoLed(int led, int tiempo)
{
  // Apagado de leds
  ledcWrite(pwmChannel1, 0);
  ledcWrite(pwmChannel2, 0);
  ledcWrite(pwmChannel3, 0);

  // Actualizacion de último LED
  switch (led)
  {
  case 1:
    ultimoLED = "R";
    break;
  case 2:
    ultimoLED = "G";
    break;
  case 3:
    ultimoLED = "A";
    break;
  }

  // Switch case para encender el led especifico
  switch (led)
  {
  case 1:
    ledcWrite(pwmChannel1, 255);
    Serial.println("Led Rojo encendido");
    break;
  case 2:
    ledcWrite(pwmChannel2, 255);
    Serial.println("Led Verde encendido");
    break;
  case 3:
    ledcWrite(pwmChannel3, 255);
    Serial.println("Led Amarillo encendido");
    break;
  default:
    Serial.println("No valido, utilizar: 1, 2 o 3");
    return;
  }
  // Esperar el tiempo especificado
  Serial.print("Tiempo: ");
  Serial.print(tiempo);
  Serial.println(" ms");
  delay(tiempo);

  // Apagar el LED después del tiempo
  switch (led)
  {
  case 1:
    ledcWrite(pwmChannel1, 0);
    break;
  case 2:
    ledcWrite(pwmChannel2, 0);
    break;
  case 3:
    ledcWrite(pwmChannel3, 0);
    break;
  }
  // Banderas para iniciar de nuevo y recibir comando
  modoComando = false;
  modoSPI = false;
}

void initSPI()
{
  // Configurar pines SPI esclavo
  SPI.begin(SPI_SCK);
  SPI.begin(SPI_MISO);
  SPI.begin(SPI_MOSI);
  SPI.begin(SPI_SS);
  pinMode(SPI_SS, INPUT);
}

void procesarComandoSPI()
{
  static unsigned long lastUpdateSPI
  // TERMINAR
}

void actualizarLCD(float voltaje, int valorBits, String ultimoLED)
{
  lcd.setCursor(0, 0);
  lcd.print("V:");
  lcd.print(voltaje, 2);
  lcd.print(" ");

  lcd.setCursor(8, 0);
  lcd.print("B:");
  lcd.print(valorBits);
  lcd.print("   "); // Espacios para limpiar caracteres anteriores

  lcd.setCursor(0, 1);
  lcd.print("Led:");
  lcd.print(ultimoLED);
  lcd.print("          "); // Espacios para limpiar caracteres anteriores
}

//******************************************/
// Configuracion
//******************************************/
void setup()
{
  Serial.begin(115200);
  initPWM();
  initSPI();
  // Para lectura de potenciometro
  analogReadResolution(12);
  analogSetAttenuation(ADC_11db);

  // Inicializacion de pantalla
  lcd.begin(16, 2);
  lcd.clear();

  // Configuracion de entradas y salidas en ESP
  pinMode(pot1, INPUT);
  pinMode(ledR, OUTPUT);
  pinMode(ledG, OUTPUT);
  pinMode(ledA, OUTPUT);

  // Configuracion para Slave
  // On receive realiza la tarea
  Wire.onReceive(onReceive);
  // On Request da info a Nucleo
  Wire.onRequest(onRequest);
  // Wire.print() --> funcion que enviaqa el valor a nucleo (master)
  Wire.begin((uint8_t)I2C_DEV_ADDR);
  Serial.println("I2C listo");

  // VSPI = CS:5, CLK: 18, MOSI: 23, MISO: 19
  // Modo SPI
  slave.setDataMode(SPI_MODE0);
  slave.setQueueSize(1);
  slave.begin(VSPI);
  // Clear buffers
  memset(spi_slave_tx_buf, 0, BUFFER_SIZE);
  memset(spi_slave_rx_buf, 0, BUFFER_SIZE);
}

//******************************************/
// Loop Principal
//******************************************/
void loop()
{
  procesarComandoSerial();
  procesarComandoSPI();
  slave.wait(spi_slave_rx_buf, spi_slave_tx_buf, BUFFER_SIZE);
  
  while (slave.available()){
    //Jalar la data del nucleo en bites, siendo este primer bite
    cmd = spi_slave_rx_buf[0]; 
    slave.pop();
    if (cmd == 1){
      //SEGUN EL COMANDO DEL NUCLEO SE REALIZAN LOS COMANDOS DEL ESP 
      //Se vacia el comando para iniciar con la siguiente instruccion
      cmd = ' ';
    }
  }

  // Espera de un comando para iniciar
  if (newCommand)
  {
    String comando = serialCommand;
    serialCommand = "";
    newCommand = false;

    // Esperar comando (formato: "LED,tiempo")
    int led, tiempo;
    if (sscanf(comando.c_str(), "%d,%d", &led, &tiempo) == 2)
    {
      if (tiempo > 0 && led >= 1 && led <= 3)
      {
        modoComando = true;
        Serial.println("\n se activa modo comando");
        ejecutarComandoLed(led, tiempo);
      }
      else
      {
        Serial.println("error: Tiempo debe ser > 0 y Led entre 1-3");
      }
    }
    else
    {
      Serial.println("error: Formato inválido. Use: Led ,Tiempo");
    }
  }

  if (!modoComando && !modoSPI)
  {
    int pot = analogRead(pot1);

    // Calculo de valores en voltaje y bits
    float voltaje = (pot * 3.3) / 4095;
    int valorBits = pot;

    // Mapeo de valores para los leds
    valorRojo = map(pot, 0, 4095, 0, 255);
    valorVerde = map(pot, 0, 4095, 0, 255);
    valorAmarillo = map(pot, 0, 4095, 0, 255);

    // Ultimo led encendido
    String ultimoLED = "";
    if (valorRojo >= valorVerde && valorRojo >= valorAmarillo)
    {
      ultimoLED = "R";
    }
    else if (valorVerde >= valorRojo && valorVerde >= valorAmarillo)
    {
      ultimoLED = "G";
    }
    else
    {
      ultimoLED = "A";
    }

    actualizarLCD(voltaje, valorBits, ultimoLED);

    // Generar señales PWM para los LEDs
    ledcWrite(pwmChannel1, valorRojo);
    ledcWrite(pwmChannel2, valorVerde);
    ledcWrite(pwmChannel3, valorAmarillo);

    delay(300);
  }
}
